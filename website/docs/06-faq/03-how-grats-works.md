# How Grats Works

For users who want to have a better mental model of how Grats works, or just for the curious, here's a high level overview of how Grats works under the hood. For a description of Grat's values and aspirations, see [Design Principles](./04-design-principles.md).

## At build time

When statically analyzing your code to infer GraphQL schema, grats first looks for your TypeScript config. From there it's able to ask the TypeScript compiler for all all the TypeScript files in your project, as well as the right configuration options to pass to the TypeScript compiler.

Grats then iterates over these files and checks via Regex to see if they contain a `@gqlType` tag. If they do, Grats will parse the file and look for any `@gqlField` tags. For each tag it finds, it asks the TypeScript compiler for that AST node to which that comment is attached. Now that Grats has an AST node and an expectation of what GraphQL construct it's trying to infer, it tries all the different inference strategies it has available to it. If it can't infer a GraphQL construct, it will report a diagnostic error to the user. That sounds a lot fancier than what the code looks like: a series of switch and if statements.

If it's able to infer a GraphQL construct, it will build up a GraphQL AST node representing the schema definition. These AST nodes are the exact shape the `graphql-js` builds when it parses a GraphQL SDL file, and so are API compatible with `graphql-js` utilties. However, we play one clever trick. When we constrcut the locaiton information for each GraphQL AST node, which would usually contain the line and column number of the SDL text from which it was parsed, we instead use the locaiton information from the TypeScript AST node, including its file path, line number, and column number.

By building up these AST nodes, Grats is able to use the same code that `graphql-js` uses to validate GraphQL schema to valdiate Grat's inferred schema. And because we have populated the locaiton information with the TypeScript AST node, the diagnostics we get from `graphql-js` will actually "point" the the TypeScript source code that Grats uses as the source of truth for that AST node.

One final clever trick we employ is using TypeScript's representation of a diagnostic. This allows us to use TypeScript's error printer for free.

In a few cases, like when a field name does not match its property/method name, Grats must communicate this fact to the runtime (see below). To achive this while still keeping the build and runtime steps separate, Grats annotates some constructs with custom server directives. On startup, these are used by the slim runtime portion of Grats to configure the GraphQL resolvers.

While this approach adds noise to the generated SDL, it allows Grats' build step to generate a single output file in a well known format, SDL.


## At runtime

Grats aims to have a very slim runtime component. Currently, it takes the SDL file generated by the build step, pass it to `graphql-js` to parse and generate a set of default resovlers (`GraphQLSchema`). Finally, it uses the directives it added to the SDL to configure/wrap the default resolvers in order to ensure they match the user's code. This includes:

- Ensuring the correct field/property is read if the field name differs from the concrete property name
- Importing and calling the correct free function if the field was defined using the [functional style of `@gqlField`](../04-dockblock-tags/02-fields.mdx#functional-style-fields) where the resolver is defined as a named export in some module or other.

In the future we might also support positional arguments which would also require some runtime configuration.