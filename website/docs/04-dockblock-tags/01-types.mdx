import GratsCode from "@site/src/components/GratsCode";
import TypesClass from "!!raw-loader!./snippets/01-types-class.out";
import TypesInterface from "!!raw-loader!./snippets/01-types-interface.out";
import TypesAlias from "!!raw-loader!./snippets/01-types-alias.out";
import TypesRenaming from "!!raw-loader!./snippets/01-types-renaming.out";
import TypesImplementInterface from "!!raw-loader!./snippets/01-types-implement-interface.out";
import TypesAliasImplementInterface from "!!raw-loader!./snippets/01-types-alias-and-implement-interface.out";
import TypesInterfaceImplementInterface from "!!raw-loader!./snippets/01-types-interface-implement-interface.out";

# Types

GraphQL types can be defined by placing a `@gqlType` docblock directly before a:

- Class declaration
- Interface declaration
- Type alias of a literal type

If model your GraphQL resolvers using classes, simply add a `@gqlType` docblock
before the class conaining that type's resolvers.

<GratsCode out={TypesClass} mode="ts" />

If youre types are represented in your code by interfaces, simply add a
`@gqlType` docblock before the interface representing that type. Note that by
using `@gqlType` on an interface, Grats will treat it as a GraphQL type and not
an interface.

<GratsCode out={TypesInterface} mode="ts" />

Finally, if your types are represented in your code by named types, simply add a
`@gqlType` docblock before the type alias which describes that type.

<GratsCode out={TypesAlias} mode="ts" />

## Renaming Types

If you want to use a different name for your type in GraphQL than in your code, you can specify the name of the type in the `@gqlType` docblock tag. See [Renaming](../03-resolvers/04-renaming.mdx) for more information.

<GratsCode out={TypesRenaming} mode="ts" />

Which would extract:

<GratsCode out={TypesRenaming} mode="gql" />

## Implementing Interfaces

:::note
Like GraphQL's schema definition language, each type which implemnts of an interface must manually define all the fields required by the interface with `/** @gqlField */` tags. Grats will not automatically inherit the fields of the interface. If you omit any fields, or fail to match types correctly, Grats will report an error.
:::

### Classes

If you are using classes to model your GraphQL resolvers, you can define your types as implementing a GraphQL interface by declaring that your class implements an interface which has been annotated with [`@gqlInterface`](./04-interfaces.mdx).

<GratsCode out={TypesImplementInterface} mode="ts" />

Will generate the following GraphQL schema:

<GratsCode out={TypesImplementInterface} mode="gql" />

### Other Declarations

If you are using an **interface** or **type alias** to define your GraphQL type, there is no TypeScript concept which cleanly maps to the GraphQL concept of an interface. In this case, you can use the `@gqlImplements` docblock tag to specify that your type implements one or more GraphQL comma separated interface. Note that with this approach you do not get TypeScript validation that you implementation implements the interface, however Grats will validate that you implement all the fields of the interface with the correct arguments and types.

#### Type Alias

<GratsCode out={TypesAliasImplementInterface} mode="ts" />

:::info
See [Interfaces](./04-interfaces.mdx) for more information about defining interfaces.
:::

#### TypeScript Interface

<GratsCode out={TypesInterfaceImplementInterface} mode="ts" />

:::note
If your type implements a GraphQL interface or is a member of a GraphQL
union, Grats will remind you to add a `__typename: "MyType"` property to your
class, type or interface.
:::
